{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/hooks/useSocket.ts"],"sourcesContent":["'use client'\r\n\r\nimport { useEffect, useRef, useState, useCallback } from 'react'\r\nimport { io, Socket } from 'socket.io-client'\r\n\r\nconst SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'https://werbrtc-server.onrender.com'\r\n\r\nlet socketInstance: Socket | null = null\r\n\r\nexport function useSocket() {\r\n  const [isConnected, setIsConnected] = useState(false)\r\n  const socketRef = useRef<Socket | null>(null)\r\n\r\n  const getSocket = useCallback(() => {\r\n    if (!socketInstance) {\r\n      socketInstance = io(SOCKET_URL, {\r\n        transports: ['websocket'],\r\n        reconnection: true,\r\n        reconnectionAttempts: 5,\r\n        reconnectionDelay: 1000,\r\n        autoConnect: false, \r\n      })\r\n    }\r\n    return socketInstance\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    const socket = getSocket()\r\n    socketRef.current = socket\r\n\r\n    const handleConnect = () => setIsConnected(true)\r\n    const handleDisconnect = () => setIsConnected(false)\r\n\r\n    socket.on('connect', handleConnect)\r\n    socket.on('disconnect', handleDisconnect)\r\n\r\n    return () => {\r\n      socket.off('connect', handleConnect)\r\n      socket.off('disconnect', handleDisconnect)\r\n    }\r\n  }, [getSocket])\r\n\r\n  const connect = useCallback(() => {\r\n    socketRef.current?.connect()\r\n  }, [])\r\n\r\n  const disconnect = useCallback(() => {\r\n    socketRef.current?.disconnect()\r\n  }, [])\r\n\r\n  const emit = useCallback(<T,>(event: string, data?: T) => {\r\n    socketRef.current?.emit(event, data)\r\n  }, [])\r\n\r\n  const on = useCallback((event: string, callback: (...args: any[]) => void) => {\r\n    socketRef.current?.on(event, callback)\r\n    return () => socketRef.current?.off(event, callback)\r\n  }, [])\r\n  const off = useCallback((event: string, callback: (...args: any[]) => void) => {\r\n    socketRef.current?.off(event, callback)\r\n    return () => socketRef.current?.off(event, callback)\r\n  }, [])\r\n\r\n\r\n  return { socket: socketRef.current, isConnected, connect, disconnect, emit, on ,off }\r\n}\r\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;AAKA,MAAM,aAAa,QAAQ,GAAG,CAAC,sBAAsB,IAAI;AAEzD,IAAI,iBAAgC;AAE7B,SAAS;IACd,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,iNAAQ,EAAC;IAC/C,MAAM,YAAY,IAAA,+MAAM,EAAgB;IAExC,MAAM,YAAY,IAAA,oNAAW,EAAC;QAC5B,IAAI,CAAC,gBAAgB;YACnB,iBAAiB,IAAA,8LAAE,EAAC,YAAY;gBAC9B,YAAY;oBAAC;iBAAY;gBACzB,cAAc;gBACd,sBAAsB;gBACtB,mBAAmB;gBACnB,aAAa;YACf;QACF;QACA,OAAO;IACT,GAAG,EAAE;IAEL,IAAA,kNAAS,EAAC;QACR,MAAM,SAAS;QACf,UAAU,OAAO,GAAG;QAEpB,MAAM,gBAAgB,IAAM,eAAe;QAC3C,MAAM,mBAAmB,IAAM,eAAe;QAE9C,OAAO,EAAE,CAAC,WAAW;QACrB,OAAO,EAAE,CAAC,cAAc;QAExB,OAAO;YACL,OAAO,GAAG,CAAC,WAAW;YACtB,OAAO,GAAG,CAAC,cAAc;QAC3B;IACF,GAAG;QAAC;KAAU;IAEd,MAAM,UAAU,IAAA,oNAAW,EAAC;QAC1B,UAAU,OAAO,EAAE;IACrB,GAAG,EAAE;IAEL,MAAM,aAAa,IAAA,oNAAW,EAAC;QAC7B,UAAU,OAAO,EAAE;IACrB,GAAG,EAAE;IAEL,MAAM,OAAO,IAAA,oNAAW,EAAC,CAAK,OAAe;QAC3C,UAAU,OAAO,EAAE,KAAK,OAAO;IACjC,GAAG,EAAE;IAEL,MAAM,KAAK,IAAA,oNAAW,EAAC,CAAC,OAAe;QACrC,UAAU,OAAO,EAAE,GAAG,OAAO;QAC7B,OAAO,IAAM,UAAU,OAAO,EAAE,IAAI,OAAO;IAC7C,GAAG,EAAE;IACL,MAAM,MAAM,IAAA,oNAAW,EAAC,CAAC,OAAe;QACtC,UAAU,OAAO,EAAE,IAAI,OAAO;QAC9B,OAAO,IAAM,UAAU,OAAO,EAAE,IAAI,OAAO;IAC7C,GAAG,EAAE;IAGL,OAAO;QAAE,QAAQ,UAAU,OAAO;QAAE;QAAa;QAAS;QAAY;QAAM;QAAI;IAAI;AACtF","debugId":null}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/provider/useWebRTC.tsx"],"sourcesContent":["\"use client\"\nimport { useSocket } from \"@/hooks/useSocket\";\nimport { createContext, ReactNode, useCallback, useContext, useEffect, useRef, useState } from \"react\";\n\ninterface MessageI { \n    messageType: 'success' | 'error', \n    message: string \n}\n\ninterface WebRtcInterface {\n    peerConnections: Map<string, RTCPeerConnection>;\n    connectAndCreateOffer: (deviceIp: string) => Promise<void>;\n    createAnswer: (deviceIp: string) => Promise<RTCSessionDescriptionInit | void>;\n    pushMessage: (msg: MessageI) => void;\n    removeMessage: (msg: MessageI) => void;\n    message: MessageI[];\n    connectedDevices: Set<string>;\n    disconnectDevice: (deviceIp: string) => void;\n}\n\nexport const WebRTCContext = createContext<WebRtcInterface | null>(null);\n\nexport const useWebRTC = (): WebRtcInterface => {\n    const context = useContext(WebRTCContext);\n    \n    if (!context) {\n        throw new Error('useWebRTC must be used within a WebRtcProvider');\n    }\n    \n    return context;\n};\n\nexport const WebRtcProvider = ({ children }: { children: ReactNode }) => {\n    const { emit, isConnected, on, off } = useSocket();\n    const [message, setMessage] = useState<MessageI[]>([]);\n    const [peerConnections, setPeerConnections] = useState<Map<string, RTCPeerConnection>>(new Map());\n    const peerConnectionsRef = useRef<Map<string, RTCPeerConnection>>(new Map());\n    const [connectedDevices, setConnectedDevices] = useState<Set<string>>(new Set());\n\n    const pushMessage = useCallback(({ message, messageType }: MessageI) => {\n        setMessage(prev => [...prev, { message, messageType }]);\n        \n        if (messageType === 'success') {\n            setTimeout(() => {\n                removeMessage({ message, messageType });\n            }, 5000);\n        }\n    }, []);\n\n    const removeMessage = useCallback(({ message, messageType }: MessageI) => {\n        setMessage(prev => prev.filter(\n            item => !(item.message === message && item.messageType === messageType)\n        ));\n    }, []);\n\n    const setupPeerConnectionListeners = useCallback((peerConnection: RTCPeerConnection, deviceIp: string) => {\n        // Connection state change listener\n        peerConnection.addEventListener('connectionstatechange', () => {\n            console.log(`ðŸ“¡ Connection state for ${deviceIp}: ${peerConnection.connectionState}`);\n            \n            switch (peerConnection.connectionState) {\n                case 'connected':\n                    console.log('âœ… WebRTC connection established with:', deviceIp);\n                    emit('webrtc-connected', { targetIp: deviceIp });\n                    setConnectedDevices(prev => new Set(prev).add(deviceIp));\n                    pushMessage({ \n                        message: `Connected to ${deviceIp}`, \n                        messageType: 'success' \n                    });\n                    break;\n                case 'connecting':\n                    console.log('ðŸ”„ Connecting to:', deviceIp);\n                    break;\n                case 'disconnected':\n                    console.log('âš ï¸ WebRTC connection disconnected:', deviceIp);\n                    setConnectedDevices(prev => {\n                        const newSet = new Set(prev);\n                        newSet.delete(deviceIp);\n                        return newSet;\n                    });\n                    break;\n                case 'failed':\n                    console.log('âŒ WebRTC connection failed:', deviceIp);\n                    setConnectedDevices(prev => {\n                        const newSet = new Set(prev);\n                        newSet.delete(deviceIp);\n                        return newSet;\n                    });\n                    emit('webrtc-disconnected', { targetIp: deviceIp });\n                    pushMessage({ \n                        message: `Connection failed with ${deviceIp}`, \n                        messageType: 'error' \n                    });\n                    break;\n                case 'closed':\n                    console.log('ðŸ”’ WebRTC connection closed:', deviceIp);\n                    setConnectedDevices(prev => {\n                        const newSet = new Set(prev);\n                        newSet.delete(deviceIp);\n                        return newSet;\n                    });\n                    emit('webrtc-disconnected', { targetIp: deviceIp });\n                    break;\n            }\n        });\n\n        // ICE connection state change listener\n        peerConnection.addEventListener('iceconnectionstatechange', () => {\n            console.log(`ðŸ§Š ICE connection state for ${deviceIp}: ${peerConnection.iceConnectionState}`);\n        });\n\n        // ICE gathering state change listener\n        peerConnection.addEventListener('icegatheringstatechange', () => {\n            console.log(`ðŸ“¡ ICE gathering state for ${deviceIp}: ${peerConnection.iceGatheringState}`);\n        });\n\n        // Signaling state change listener\n        peerConnection.addEventListener('signalingstatechange', () => {\n            console.log(`ðŸ“¶ Signaling state for ${deviceIp}: ${peerConnection.signalingState}`);\n        });\n\n        // ICE candidate handler\n        peerConnection.onicecandidate = (event: RTCPeerConnectionIceEvent) => {\n            if (event.candidate) {\n                console.log('ðŸ§Š Sending ICE candidate to:', deviceIp, event.candidate.type);\n                emit('ice-candidate', {\n                    targetIp: deviceIp,\n                    candidate: event.candidate.toJSON()\n                });\n            } else {\n                console.log('âœ… ICE gathering complete for:', deviceIp);\n            }\n        };\n    }, [emit, pushMessage]);\n\n    const connectAndCreateOffer = useCallback(async (deviceIp: string) => {\n        if (!isConnected) {\n            pushMessage({ message: 'Socket is not connected', messageType: 'error' });\n            return;\n        }\n        if (!deviceIp) {\n            pushMessage({ message: 'Invalid device IP', messageType: 'error' });\n            return;\n        }\n\n        let peerConnection = peerConnectionsRef.current.get(deviceIp);\n        \n        if (!peerConnection) {\n            console.log('ðŸ”Œ Creating peer connection for:', deviceIp);\n\n            peerConnection = new RTCPeerConnection({\n                iceServers: [\n                    { urls: 'stun:stun.l.google.com:19302' },\n                    { urls: 'stun:stun1.l.google.com:19302' },\n                    { urls: 'stun:stun2.l.google.com:19302' }\n                ],\n                iceCandidatePoolSize: 10\n            });\n\n            setupPeerConnectionListeners(peerConnection, deviceIp);\n\n            // Update both ref and state\n            const newPeerConnections = new Map(peerConnectionsRef.current);\n            newPeerConnections.set(deviceIp, peerConnection);\n            peerConnectionsRef.current = newPeerConnections;\n            setPeerConnections(newPeerConnections);\n        }\n\n        try {\n            console.log('ðŸ“¤ Creating offer for:', deviceIp);\n            const offer = await peerConnection.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            });\n            \n            console.log('ðŸ“ Setting local description (offer)');\n            await peerConnection.setLocalDescription(offer);\n            \n            console.log('ðŸ“¤ Sending offer via socket');\n            emit('offer', {\n                targetIp: deviceIp,\n                sdp: peerConnection.localDescription\n            });\n        } catch (error) {\n            console.error('âŒ Error creating offer:', error);\n            pushMessage({ message: 'Failed to create offer', messageType: 'error' });\n        }\n    }, [isConnected, emit, pushMessage, setupPeerConnectionListeners]);\n\n    const createAnswer = useCallback(async (deviceIp: string) => {\n        if (!isConnected) {\n            pushMessage({ message: 'Socket is not connected', messageType: 'error' });\n            return;\n        }\n        if (!deviceIp) {\n            pushMessage({ message: 'Invalid device IP', messageType: 'error' });\n            return;\n        }\n\n        const peerConnection = peerConnectionsRef.current.get(deviceIp);\n        if (!peerConnection) {\n            pushMessage({ message: 'Peer connection not found', messageType: 'error' });\n            return;\n        }\n\n        try {\n            console.log('ðŸ“¥ Creating answer for:', deviceIp);\n            const answer = await peerConnection.createAnswer();\n            \n            console.log('ðŸ“ Setting local description (answer)');\n            await peerConnection.setLocalDescription(answer);\n            \n            console.log('ðŸ“¤ Sending answer via socket');\n            emit('answer', {\n                targetIp: deviceIp,\n                sdp: peerConnection.localDescription\n            });\n\n            return answer;\n        } catch (error) {\n            console.error('âŒ Error creating answer:', error);\n            pushMessage({ message: 'Failed to create answer', messageType: 'error' });\n        }\n    }, [isConnected, emit, pushMessage]);\n\n    const disconnectDevice = useCallback((deviceIp: string) => {\n        const peerConnection = peerConnectionsRef.current.get(deviceIp);\n        \n        if (peerConnection) {\n            console.log('ðŸ”Œ Closing peer connection for:', deviceIp);\n            peerConnection.close();\n            \n            const newPeerConnections = new Map(peerConnectionsRef.current);\n            newPeerConnections.delete(deviceIp);\n            peerConnectionsRef.current = newPeerConnections;\n            setPeerConnections(newPeerConnections);\n            \n            setConnectedDevices(prev => {\n                const newSet = new Set(prev);\n                newSet.delete(deviceIp);\n                return newSet;\n            });\n\n            emit('webrtc-disconnected', { targetIp: deviceIp });\n        }\n    }, [emit]);\n\n    const createPeerConnectionIfNotExists = useCallback(async (deviceIp: string) => {\n        if (peerConnectionsRef.current.has(deviceIp)) {\n            return peerConnectionsRef.current.get(deviceIp);\n        }\n\n        console.log('ðŸ”Œ Creating peer connection for incoming connection:', deviceIp);\n\n        const peerConnection = new RTCPeerConnection({\n            iceServers: [\n                { urls: 'stun:stun.l.google.com:19302' },\n                { urls: 'stun:stun1.l.google.com:19302' },\n                { urls: 'stun:stun2.l.google.com:19302' }\n            ],\n            iceCandidatePoolSize: 10\n        });\n\n        setupPeerConnectionListeners(peerConnection, deviceIp);\n\n        // Update both ref and state\n        const newPeerConnections = new Map(peerConnectionsRef.current);\n        newPeerConnections.set(deviceIp, peerConnection);\n        peerConnectionsRef.current = newPeerConnections;\n        setPeerConnections(newPeerConnections);\n\n        return peerConnection;\n    }, [setupPeerConnectionListeners]);\n\n    useEffect(() => {\n        if (!isConnected) {\n            return;\n        }\n\n        // Handle incoming offer\n        const handleOffer = async (data: { from: string; sdp: RTCSessionDescriptionInit }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ“¥ Received offer from:', fromDeviceIp);\n\n            const peerConnection = await createPeerConnectionIfNotExists(fromDeviceIp);\n            if (!peerConnection) {\n                pushMessage({ message: 'Failed to create peer connection', messageType: 'error' });\n                return;\n            }\n\n            try {\n                console.log('ðŸ“ Setting remote description (offer)');\n                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));\n                console.log('âœ… Remote description set successfully');\n                \n                await createAnswer(fromDeviceIp);\n            } catch (error) {\n                console.error('âŒ Error handling offer:', error);\n                pushMessage({ message: 'Failed to handle offer', messageType: 'error' });\n            }\n        };\n\n        // Handle incoming answer\n        const handleAnswer = async (data: { from: string; sdp: RTCSessionDescriptionInit }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ“¥ Received answer from:', fromDeviceIp);\n\n            const peerConnection = peerConnectionsRef.current.get(fromDeviceIp);\n            if (!peerConnection) {\n                console.error('âŒ Peer connection not found for answer');\n                pushMessage({ message: 'Peer connection not found', messageType: 'error' });\n                return;\n            }\n\n            try {\n                console.log('ðŸ“ Setting remote description (answer)');\n                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));\n                console.log('âœ… Remote description (answer) set successfully');\n            } catch (error) {\n                console.error('âŒ Error handling answer:', error);\n                pushMessage({ message: 'Failed to handle answer', messageType: 'error' });\n            }\n        };\n\n        // Handle incoming ICE candidate\n        const handleIceCandidate = async (data: { from: string; candidate: RTCIceCandidateInit }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ§Š Received ICE candidate from:', fromDeviceIp, data.candidate);\n\n            const peerConnection = peerConnectionsRef.current.get(fromDeviceIp);\n            if (!peerConnection) {\n                console.error('âŒ Peer connection not found for ICE candidate');\n                return;\n            }\n\n            try {\n                if (peerConnection.remoteDescription) {\n                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));\n                    console.log('âœ… ICE candidate added successfully');\n                } else {\n                    console.warn('âš ï¸ Remote description not set yet, queuing ICE candidate');\n                    // Queue the candidate for later\n                    setTimeout(async () => {\n                        if (peerConnection.remoteDescription) {\n                            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));\n                            console.log('âœ… Queued ICE candidate added successfully');\n                        }\n                    }, 100);\n                }\n            } catch (err) {\n                console.error(\"âŒ Error adding ICE candidate:\", err);\n            }\n        };\n\n        // Handle connection notification from other device\n        const handleWebRTCConnected = (data: { fromIp: string }) => {\n            console.log('âœ… Received connection notification from:', data.fromIp);\n            setConnectedDevices(prev => new Set(prev).add(data.fromIp));\n        };\n\n        // Handle disconnection notification\n        const handleWebRTCDisconnected = (data: { fromIp: string }) => {\n            console.log('âŒ Received disconnection notification from:', data.fromIp);\n            setConnectedDevices(prev => {\n                const newSet = new Set(prev);\n                newSet.delete(data.fromIp);\n                return newSet;\n            });\n        };\n\n        on('offer', handleOffer);\n        on('answer', handleAnswer);\n        on('ice-candidate', handleIceCandidate);\n        on('webrtc-connection-notify', handleWebRTCConnected);\n        on('webrtc-disconnection-notify', handleWebRTCDisconnected);\n\n        return () => {\n            off('offer', handleOffer);\n            off('answer', handleAnswer);\n            off('ice-candidate', handleIceCandidate);\n            off('webrtc-connection-notify', handleWebRTCConnected);\n            off('webrtc-disconnection-notify', handleWebRTCDisconnected);\n        };\n    }, [isConnected, on, off, createAnswer, createPeerConnectionIfNotExists, pushMessage]);\n\n    return (\n        <WebRTCContext.Provider value={{ \n            peerConnections, \n            connectAndCreateOffer,\n            createAnswer, \n            removeMessage, \n            pushMessage, \n            message,\n            connectedDevices,\n            disconnectDevice\n        }}>\n            {children}\n        </WebRTCContext.Provider>\n    );\n};\n"],"names":[],"mappings":"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","debugId":null}}]
}