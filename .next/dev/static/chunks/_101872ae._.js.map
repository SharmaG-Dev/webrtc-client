{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/provider/useSocket.tsx"],"sourcesContent":["'use client'\n\nimport { createContext, useContext, useEffect, useRef, useState, useCallback, ReactNode } from 'react'\nimport { io, Socket } from 'socket.io-client'\n\nconst SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'https://werbrtc-server.onrender.com'\n\ninterface SocketContextType {\n  socket: Socket | null\n  isConnected: boolean\n  connect: () => void\n  disconnect: () => void\n  emit: <T>(event: string, data?: T) => void\n  on: (event: string, callback: (...args: any[]) => void) => () => void\n  off: (event: string, callback: (...args: any[]) => void) => () => void\n}\n\nconst SocketContext = createContext<SocketContextType | null>(null)\n\nlet socketInstance: Socket | null = null\n\nexport function SocketProvider({ children }: { children: ReactNode }) {\n  const [isConnected, setIsConnected] = useState(false)\n  const socketRef = useRef<Socket | null>(null)\n\n  const getSocket = useCallback(() => {\n    if (!socketInstance) {\n      socketInstance = io(SOCKET_URL, {\n        transports: ['websocket'],\n        reconnection: true,\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000,\n        autoConnect: false,\n      })\n    }\n    return socketInstance\n  }, [])\n\n  useEffect(() => {\n    const socket = getSocket()\n    socketRef.current = socket\n\n    const handleConnect = () => setIsConnected(true)\n    const handleDisconnect = () => setIsConnected(false)\n\n    socket.on('connect', handleConnect)\n    socket.on('disconnect', handleDisconnect)\n\n    return () => {\n      socket.off('connect', handleConnect)\n      socket.off('disconnect', handleDisconnect)\n    }\n  }, [getSocket])\n\n  const connect = useCallback(() => {\n    socketRef.current?.connect()\n  }, [])\n\n  const disconnect = useCallback(() => {\n    socketRef.current?.disconnect()\n  }, [])\n\n  const emit = useCallback(<T,>(event: string, data?: T) => {\n    socketRef.current?.emit(event, data)\n  }, [])\n\n  const on = useCallback((event: string, callback: (...args: any[]) => void) => {\n    socketRef.current?.on(event, callback)\n    return () => socketRef.current?.off(event, callback)\n  }, [])\n\n  const off = useCallback((event: string, callback: (...args: any[]) => void) => {\n    socketRef.current?.off(event, callback)\n    return () => socketRef.current?.off(event, callback)\n  }, [])\n\n  const value: SocketContextType = {\n    socket: socketRef.current,\n    isConnected,\n    connect,\n    disconnect,\n    emit,\n    on,\n    off\n  }\n\n  return (\n    <SocketContext.Provider value={value}>\n      {children}\n    </SocketContext.Provider>\n  )\n}\n\n// Custom hook to use the socket context\nexport function useSocket() {\n  const context = useContext(SocketContext)\n  \n  if (!context) {\n    throw new Error('useSocket must be used within a SocketProvider')\n  }\n  \n  return context\n}\n"],"names":[],"mappings":";;;;;;AAKmB;;AAHnB;AACA;;;AAHA;;;AAKA,MAAM,aAAa,2KAAO,CAAC,GAAG,CAAC,sBAAsB,IAAI;AAYzD,MAAM,8BAAgB,IAAA,8KAAa,EAA2B;AAE9D,IAAI,iBAAgC;AAE7B,SAAS,eAAe,EAAE,QAAQ,EAA2B;;IAClE,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAC;IAC/C,MAAM,YAAY,IAAA,uKAAM,EAAgB;IAExC,MAAM,YAAY,IAAA,4KAAW;iDAAC;YAC5B,IAAI,CAAC,gBAAgB;gBACnB,iBAAiB,IAAA,wLAAE,EAAC,YAAY;oBAC9B,YAAY;wBAAC;qBAAY;oBACzB,cAAc;oBACd,sBAAsB;oBACtB,mBAAmB;oBACnB,aAAa;gBACf;YACF;YACA,OAAO;QACT;gDAAG,EAAE;IAEL,IAAA,0KAAS;oCAAC;YACR,MAAM,SAAS;YACf,UAAU,OAAO,GAAG;YAEpB,MAAM;0DAAgB,IAAM,eAAe;;YAC3C,MAAM;6DAAmB,IAAM,eAAe;;YAE9C,OAAO,EAAE,CAAC,WAAW;YACrB,OAAO,EAAE,CAAC,cAAc;YAExB;4CAAO;oBACL,OAAO,GAAG,CAAC,WAAW;oBACtB,OAAO,GAAG,CAAC,cAAc;gBAC3B;;QACF;mCAAG;QAAC;KAAU;IAEd,MAAM,UAAU,IAAA,4KAAW;+CAAC;YAC1B,UAAU,OAAO,EAAE;QACrB;8CAAG,EAAE;IAEL,MAAM,aAAa,IAAA,4KAAW;kDAAC;YAC7B,UAAU,OAAO,EAAE;QACrB;iDAAG,EAAE;IAEL,MAAM,OAAO,IAAA,4KAAW;4CAAC,CAAK,OAAe;YAC3C,UAAU,OAAO,EAAE,KAAK,OAAO;QACjC;2CAAG,EAAE;IAEL,MAAM,KAAK,IAAA,4KAAW;0CAAC,CAAC,OAAe;YACrC,UAAU,OAAO,EAAE,GAAG,OAAO;YAC7B;kDAAO,IAAM,UAAU,OAAO,EAAE,IAAI,OAAO;;QAC7C;yCAAG,EAAE;IAEL,MAAM,MAAM,IAAA,4KAAW;2CAAC,CAAC,OAAe;YACtC,UAAU,OAAO,EAAE,IAAI,OAAO;YAC9B;mDAAO,IAAM,UAAU,OAAO,EAAE,IAAI,OAAO;;QAC7C;0CAAG,EAAE;IAEL,MAAM,QAA2B;QAC/B,QAAQ,UAAU,OAAO;QACzB;QACA;QACA;QACA;QACA;QACA;IACF;IAEA,qBACE,6LAAC,cAAc,QAAQ;QAAC,OAAO;kBAC5B;;;;;;AAGP;GAtEgB;KAAA;AAyET,SAAS;;IACd,MAAM,UAAU,IAAA,2KAAU,EAAC;IAE3B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;IARgB","debugId":null}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/provider/useWebRTC.tsx"],"sourcesContent":["\"use client\"\n\nimport { createContext, ReactNode, useCallback, useContext, useEffect, useRef, useState } from \"react\";\nimport { useSocket } from \"./useSocket\";\n\ninterface MessageI { \n    messageType: 'success' | 'error', \n    message: string \n}\n\ninterface WebRtcInterface {\n    peerConnections: Map<string, RTCPeerConnection>;\n    connectAndCreateOffer: (deviceIp: string) => Promise<void>;\n    createAnswer: (deviceIp: string) => Promise<RTCSessionDescriptionInit | void>;\n    pushMessage: (msg: MessageI) => void;\n    removeMessage: (msg: MessageI) => void;\n    message: MessageI[];\n    connectedDevices: Set<string>;\n    disconnectDevice: (deviceIp: string) => void;\n    dataChannels: Map<string, RTCDataChannel>;\n}\n\nexport const WebRTCContext = createContext<WebRtcInterface | null>(null);\n\nexport const useWebRTC = (): WebRtcInterface => {\n    const context = useContext(WebRTCContext);\n    \n    if (!context) {\n        throw new Error('useWebRTC must be used within a WebRtcProvider');\n    }\n    \n    return context;\n};\n\nexport const WebRtcProvider = ({ children }: { children: ReactNode }) => {\n    const { emit, isConnected, on, off } = useSocket();\n    const [message, setMessage] = useState<MessageI[]>([]);\n    const [peerConnections, setPeerConnections] = useState<Map<string, RTCPeerConnection>>(new Map());\n    const peerConnectionsRef = useRef<Map<string, RTCPeerConnection>>(new Map());\n    const [connectedDevices, setConnectedDevices] = useState<Set<string>>(new Set());\n    const [dataChannels, setDataChannels] = useState<Map<string, RTCDataChannel>>(new Map());\n    const dataChannelsRef = useRef<Map<string, RTCDataChannel>>(new Map());\n\n    const pushMessage = useCallback(({ message, messageType }: MessageI) => {\n        setMessage(prev => [...prev, { message, messageType }]);\n        \n        if (messageType === 'success') {\n            setTimeout(() => {\n                removeMessage({ message, messageType });\n            }, 5000);\n        }\n    }, []);\n\n    const removeMessage = useCallback(({ message, messageType }: MessageI) => {\n        setMessage(prev => prev.filter(\n            item => !(item.message === message && item.messageType === messageType)\n        ));\n    }, []);\n\n    const setupPeerConnectionListeners = useCallback((peerConnection: RTCPeerConnection, deviceIp: string) => {\n        // Connection state change listener\n        peerConnection.addEventListener('connectionstatechange', () => {\n            console.log(`ðŸ“¡ Connection state for ${deviceIp}: ${peerConnection.connectionState}`);\n            \n            switch (peerConnection.connectionState) {\n                case 'connected':\n                    console.log('âœ… WebRTC connection established with:', deviceIp);\n                    emit('webrtc-connected', { targetIp: deviceIp });\n                    setConnectedDevices(prev => new Set(prev).add(deviceIp));\n                    pushMessage({ \n                        message: `Connected to ${deviceIp}`, \n                        messageType: 'success' \n                    });\n                    break;\n                case 'connecting':\n                    console.log('ðŸ”„ Connecting to:', deviceIp);\n                    break;\n                case 'disconnected':\n                    console.log('âš ï¸ WebRTC connection disconnected:', deviceIp);\n                    setConnectedDevices(prev => {\n                        const newSet = new Set(prev);\n                        newSet.delete(deviceIp);\n                        return newSet;\n                    });\n                    break;\n                case 'failed':\n                    console.log('âŒ WebRTC connection failed:', deviceIp);\n                    setConnectedDevices(prev => {\n                        const newSet = new Set(prev);\n                        newSet.delete(deviceIp);\n                        return newSet;\n                    });\n                    emit('webrtc-disconnected', { targetIp: deviceIp });\n                    pushMessage({ \n                        message: `Connection failed with ${deviceIp}`, \n                        messageType: 'error' \n                    });\n                    break;\n                case 'closed':\n                    console.log('ðŸ”’ WebRTC connection closed:', deviceIp);\n                    setConnectedDevices(prev => {\n                        const newSet = new Set(prev);\n                        newSet.delete(deviceIp);\n                        return newSet;\n                    });\n                    emit('webrtc-disconnected', { targetIp: deviceIp });\n                    break;\n            }\n        });\n\n        // ICE connection state change listener\n        peerConnection.addEventListener('iceconnectionstatechange', () => {\n            console.log(`ðŸ§Š ICE connection state for ${deviceIp}: ${peerConnection.iceConnectionState}`);\n        });\n\n        // ICE gathering state change listener\n        peerConnection.addEventListener('icegatheringstatechange', () => {\n            console.log(`ðŸ“¡ ICE gathering state for ${deviceIp}: ${peerConnection.iceGatheringState}`);\n        });\n\n        // Signaling state change listener\n        peerConnection.addEventListener('signalingstatechange', () => {\n            console.log(`ðŸ“¶ Signaling state for ${deviceIp}: ${peerConnection.signalingState}`);\n        });\n\n        // ICE candidate handler\n        peerConnection.onicecandidate = (event: RTCPeerConnectionIceEvent) => {\n            if (event.candidate) {\n                console.log('ðŸ§Š Sending ICE candidate to:', deviceIp, event.candidate.type);\n                emit('ice-candidate', {\n                    targetIp: deviceIp,\n                    candidate: event.candidate.toJSON()\n                });\n            } else {\n                console.log('âœ… ICE gathering complete for:', deviceIp);\n            }\n        };\n\n        // DataChannel listener (for receiving side)\n        peerConnection.addEventListener('datachannel', (event) => {\n            console.log('ðŸ“¨ DataChannel received from:', deviceIp);\n            const dataChannel = event.channel;\n            \n            setupDataChannelListeners(dataChannel, deviceIp);\n            \n            const newDataChannels = new Map(dataChannelsRef.current);\n            newDataChannels.set(deviceIp, dataChannel);\n            dataChannelsRef.current = newDataChannels;\n            setDataChannels(newDataChannels);\n        });\n\n    }, [emit, pushMessage]);\n\n    const setupDataChannelListeners = useCallback((dataChannel: RTCDataChannel, deviceIp: string) => {\n        dataChannel.addEventListener('open', () => {\n            console.log('âœ… DataChannel opened for:', deviceIp);\n            pushMessage({\n                message: `Chat ready with ${deviceIp}`,\n                messageType: 'success'\n            });\n        });\n\n        dataChannel.addEventListener('close', () => {\n            console.log('âŒ DataChannel closed for:', deviceIp);\n            const newDataChannels = new Map(dataChannelsRef.current);\n            newDataChannels.delete(deviceIp);\n            dataChannelsRef.current = newDataChannels;\n            setDataChannels(newDataChannels);\n        });\n\n        dataChannel.addEventListener('error', (error) => {\n            console.error('âŒ DataChannel error:', error);\n        });\n    }, [pushMessage]);\n\n    const connectAndCreateOffer = useCallback(async (deviceIp: string) => {\n        if (!isConnected) {\n            pushMessage({ message: 'Socket is not connected', messageType: 'error' });\n            return;\n        }\n        if (!deviceIp) {\n            pushMessage({ message: 'Invalid device IP', messageType: 'error' });\n            return;\n        }\n\n        let peerConnection = peerConnectionsRef.current.get(deviceIp);\n        \n        if (!peerConnection) {\n            console.log('ðŸ”Œ Creating peer connection for:', deviceIp);\n\n            peerConnection = new RTCPeerConnection({\n                iceServers: [\n                    { urls: 'stun:stun.l.google.com:19302' },\n                    { urls: 'stun:stun1.l.google.com:19302' },\n                    { urls: 'stun:stun2.l.google.com:19302' }\n                ],\n                iceCandidatePoolSize: 10\n            });\n\n            setupPeerConnectionListeners(peerConnection, deviceIp);\n\n            // Create DataChannel (for initiating side)\n            console.log('ðŸ“¨ Creating DataChannel for:', deviceIp);\n            const dataChannel = peerConnection.createDataChannel('chat', {\n                ordered: true\n            });\n\n            setupDataChannelListeners(dataChannel, deviceIp);\n\n            const newDataChannels = new Map(dataChannelsRef.current);\n            newDataChannels.set(deviceIp, dataChannel);\n            dataChannelsRef.current = newDataChannels;\n            setDataChannels(newDataChannels);\n\n            // Update both ref and state\n            const newPeerConnections = new Map(peerConnectionsRef.current);\n            newPeerConnections.set(deviceIp, peerConnection);\n            peerConnectionsRef.current = newPeerConnections;\n            setPeerConnections(newPeerConnections);\n        }\n\n        try {\n            console.log('ðŸ“¤ Creating offer for:', deviceIp);\n            const offer = await peerConnection.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            });\n            \n            console.log('ðŸ“ Setting local description (offer)');\n            await peerConnection.setLocalDescription(offer);\n            \n            console.log('ðŸ“¤ Sending offer via socket');\n            emit('offer', {\n                targetIp: deviceIp,\n                sdp: peerConnection.localDescription\n            });\n        } catch (error) {\n            console.error('âŒ Error creating offer:', error);\n            pushMessage({ message: 'Failed to create offer', messageType: 'error' });\n        }\n    }, [isConnected, emit, pushMessage, setupPeerConnectionListeners, setupDataChannelListeners]);\n\n    const createAnswer = useCallback(async (deviceIp: string) => {\n        if (!isConnected) {\n            pushMessage({ message: 'Socket is not connected', messageType: 'error' });\n            return;\n        }\n        if (!deviceIp) {\n            pushMessage({ message: 'Invalid device IP', messageType: 'error' });\n            return;\n        }\n\n        const peerConnection = peerConnectionsRef.current.get(deviceIp);\n        if (!peerConnection) {\n            pushMessage({ message: 'Peer connection not found', messageType: 'error' });\n            return;\n        }\n\n        try {\n            console.log('ðŸ“¥ Creating answer for:', deviceIp);\n            const answer = await peerConnection.createAnswer();\n            \n            console.log('ðŸ“ Setting local description (answer)');\n            await peerConnection.setLocalDescription(answer);\n            \n            console.log('ðŸ“¤ Sending answer via socket');\n            emit('answer', {\n                targetIp: deviceIp,\n                sdp: peerConnection.localDescription\n            });\n\n            return answer;\n        } catch (error) {\n            console.error('âŒ Error creating answer:', error);\n            pushMessage({ message: 'Failed to create answer', messageType: 'error' });\n        }\n    }, [isConnected, emit, pushMessage]);\n\n    const disconnectDevice = useCallback((deviceIp: string) => {\n        const peerConnection = peerConnectionsRef.current.get(deviceIp);\n        const dataChannel = dataChannelsRef.current.get(deviceIp);\n        \n        if (dataChannel) {\n            console.log('ðŸ“¨ Closing DataChannel for:', deviceIp);\n            dataChannel.close();\n            \n            const newDataChannels = new Map(dataChannelsRef.current);\n            newDataChannels.delete(deviceIp);\n            dataChannelsRef.current = newDataChannels;\n            setDataChannels(newDataChannels);\n        }\n\n        if (peerConnection) {\n            console.log('ðŸ”Œ Closing peer connection for:', deviceIp);\n            peerConnection.close();\n            \n            const newPeerConnections = new Map(peerConnectionsRef.current);\n            newPeerConnections.delete(deviceIp);\n            peerConnectionsRef.current = newPeerConnections;\n            setPeerConnections(newPeerConnections);\n            \n            setConnectedDevices(prev => {\n                const newSet = new Set(prev);\n                newSet.delete(deviceIp);\n                return newSet;\n            });\n\n            emit('webrtc-disconnected', { targetIp: deviceIp });\n        }\n    }, [emit]);\n\n    const createPeerConnectionIfNotExists = useCallback(async (deviceIp: string) => {\n        if (peerConnectionsRef.current.has(deviceIp)) {\n            return peerConnectionsRef.current.get(deviceIp);\n        }\n\n        console.log('ðŸ”Œ Creating peer connection for incoming connection:', deviceIp);\n\n        const peerConnection = new RTCPeerConnection({\n            iceServers: [\n                { urls: 'stun:stun.l.google.com:19302' },\n                { urls: 'stun:stun1.l.google.com:19302' },\n                { urls: 'stun:stun2.l.google.com:19302' }\n            ],\n            iceCandidatePoolSize: 10\n        });\n\n        setupPeerConnectionListeners(peerConnection, deviceIp);\n\n        // Update both ref and state\n        const newPeerConnections = new Map(peerConnectionsRef.current);\n        newPeerConnections.set(deviceIp, peerConnection);\n        peerConnectionsRef.current = newPeerConnections;\n        setPeerConnections(newPeerConnections);\n\n        return peerConnection;\n    }, [setupPeerConnectionListeners]);\n\n    useEffect(() => {\n        if (!isConnected) {\n            return;\n        }\n\n        // Handle incoming offer\n        const handleOffer = async (data: { from: string; sdp: RTCSessionDescriptionInit }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ“¥ Received offer from:', fromDeviceIp);\n\n            const peerConnection = await createPeerConnectionIfNotExists(fromDeviceIp);\n            if (!peerConnection) {\n                pushMessage({ message: 'Failed to create peer connection', messageType: 'error' });\n                return;\n            }\n\n            try {\n                console.log('ðŸ“ Setting remote description (offer)');\n                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));\n                console.log('âœ… Remote description set successfully');\n                \n                await createAnswer(fromDeviceIp);\n            } catch (error) {\n                console.error('âŒ Error handling offer:', error);\n                pushMessage({ message: 'Failed to handle offer', messageType: 'error' });\n            }\n        };\n\n        // Handle incoming answer\n        const handleAnswer = async (data: { from: string; sdp: RTCSessionDescriptionInit }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ“¥ Received answer from:', fromDeviceIp);\n\n            const peerConnection = peerConnectionsRef.current.get(fromDeviceIp);\n            if (!peerConnection) {\n                console.error('âŒ Peer connection not found for answer');\n                pushMessage({ message: 'Peer connection not found', messageType: 'error' });\n                return;\n            }\n\n            try {\n                console.log('ðŸ“ Setting remote description (answer)');\n                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));\n                console.log('âœ… Remote description (answer) set successfully');\n            } catch (error) {\n                console.error('âŒ Error handling answer:', error);\n                pushMessage({ message: 'Failed to handle answer', messageType: 'error' });\n            }\n        };\n\n        // Handle incoming ICE candidate\n        const handleIceCandidate = async (data: { from: string; candidate: RTCIceCandidateInit }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ§Š Received ICE candidate from:', fromDeviceIp, data.candidate);\n\n            const peerConnection = peerConnectionsRef.current.get(fromDeviceIp);\n            if (!peerConnection) {\n                console.error('âŒ Peer connection not found for ICE candidate');\n                return;\n            }\n\n            try {\n                if (peerConnection.remoteDescription) {\n                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));\n                    console.log('âœ… ICE candidate added successfully');\n                } else {\n                    console.warn('âš ï¸ Remote description not set yet, queuing ICE candidate');\n                    // Queue the candidate for later\n                    setTimeout(async () => {\n                        if (peerConnection.remoteDescription) {\n                            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));\n                            console.log('âœ… Queued ICE candidate added successfully');\n                        }\n                    }, 100);\n                }\n            } catch (err) {\n                console.error(\"âŒ Error adding ICE candidate:\", err);\n            }\n        };\n\n        // Handle connection notification from other device\n        const handleWebRTCConnected = (data: { fromIp: string }) => {\n            console.log('âœ… Received connection notification from:', data.fromIp);\n            setConnectedDevices(prev => new Set(prev).add(data.fromIp));\n        };\n\n        // Handle disconnection notification\n        const handleWebRTCDisconnected = (data: { fromIp: string }) => {\n            console.log('âŒ Received disconnection notification from:', data.fromIp);\n            setConnectedDevices(prev => {\n                const newSet = new Set(prev);\n                newSet.delete(data.fromIp);\n                return newSet;\n            });\n        };\n\n        on('offer', handleOffer);\n        on('answer', handleAnswer);\n        on('ice-candidate', handleIceCandidate);\n        on('webrtc-connection-notify', handleWebRTCConnected);\n        on('webrtc-disconnection-notify', handleWebRTCDisconnected);\n\n        return () => {\n            off('offer', handleOffer);\n            off('answer', handleAnswer);\n            off('ice-candidate', handleIceCandidate);\n            off('webrtc-connection-notify', handleWebRTCConnected);\n            off('webrtc-disconnection-notify', handleWebRTCDisconnected);\n        };\n    }, [isConnected, on, off, createAnswer, createPeerConnectionIfNotExists, pushMessage]);\n\n    return (\n        <WebRTCContext.Provider value={{ \n            peerConnections, \n            connectAndCreateOffer,\n            createAnswer, \n            removeMessage, \n            pushMessage, \n            message,\n            connectedDevices,\n            disconnectDevice,\n            dataChannels\n        }}>\n            {children}\n        </WebRTCContext.Provider>\n    );\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 704, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/store/slices/state.slice.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { DeviceData } from '@/hooks/useDeviceInfo'\n\ninterface DeviceState {\n    isConnected: boolean\n    devices: DeviceData[]\n    selectedDevice: DeviceData | null\n    deviceConnected: boolean | null\n    isRegistering: boolean\n    incomingConnections: Record<string, { name: string; ip: string }>\n}\n\nconst initialState: DeviceState = {\n    isConnected: false,\n    devices: [],\n    selectedDevice: null,\n    deviceConnected: null,\n    isRegistering: false,\n    incomingConnections: {}\n}\n\nexport const deviceSlice = createSlice({\n    name: 'device',\n    initialState,\n    reducers: {\n        setDevices: (state, action: PayloadAction<DeviceData[]>) => {\n            state.devices = action.payload\n        },\n        setSelectedDevice: (state, action: PayloadAction<DeviceData | null>) => {\n            state.selectedDevice = action.payload\n        },\n        setDeviceConnected: (state, action: PayloadAction<boolean | null>) => {\n            state.deviceConnected = action.payload\n        },\n        setIsRegistering: (state, action: PayloadAction<boolean>) => {\n            state.isRegistering = action.payload\n        },\n        addIncomingConnection: (state, action: PayloadAction<{ ip: string; name: string }>) => {\n            state.incomingConnections[action.payload.ip] = {\n                name: action.payload.name,\n                ip: action.payload.ip\n            }\n        },\n        removeIncomingConnection: (state, action: PayloadAction<string>) => {\n            delete state.incomingConnections[action.payload]\n        },\n        clearIncomingConnections: (state) => {\n            state.incomingConnections = {}\n        },\n        clearDeviceState: (state) => {\n            state.devices = []\n            state.selectedDevice = null\n            state.deviceConnected = null\n            state.incomingConnections = {}\n        },\n        setIsConnected: (state, action:PayloadAction<boolean>) => {\n            state.isConnected = action.payload\n        }\n    }\n})\n\nexport const {\n    setDevices,\n    setSelectedDevice,\n    setDeviceConnected,\n    setIsRegistering,\n    addIncomingConnection,\n    removeIncomingConnection,\n    clearIncomingConnections,\n    clearDeviceState,\n    setIsConnected\n} = deviceSlice.actions\n\nexport default deviceSlice.reducer\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAYA,MAAM,eAA4B;IAC9B,aAAa;IACb,SAAS,EAAE;IACX,gBAAgB;IAChB,iBAAiB;IACjB,eAAe;IACf,qBAAqB,CAAC;AAC1B;AAEO,MAAM,cAAc,IAAA,6MAAW,EAAC;IACnC,MAAM;IACN;IACA,UAAU;QACN,YAAY,CAAC,OAAO;YAChB,MAAM,OAAO,GAAG,OAAO,OAAO;QAClC;QACA,mBAAmB,CAAC,OAAO;YACvB,MAAM,cAAc,GAAG,OAAO,OAAO;QACzC;QACA,oBAAoB,CAAC,OAAO;YACxB,MAAM,eAAe,GAAG,OAAO,OAAO;QAC1C;QACA,kBAAkB,CAAC,OAAO;YACtB,MAAM,aAAa,GAAG,OAAO,OAAO;QACxC;QACA,uBAAuB,CAAC,OAAO;YAC3B,MAAM,mBAAmB,CAAC,OAAO,OAAO,CAAC,EAAE,CAAC,GAAG;gBAC3C,MAAM,OAAO,OAAO,CAAC,IAAI;gBACzB,IAAI,OAAO,OAAO,CAAC,EAAE;YACzB;QACJ;QACA,0BAA0B,CAAC,OAAO;YAC9B,OAAO,MAAM,mBAAmB,CAAC,OAAO,OAAO,CAAC;QACpD;QACA,0BAA0B,CAAC;YACvB,MAAM,mBAAmB,GAAG,CAAC;QACjC;QACA,kBAAkB,CAAC;YACf,MAAM,OAAO,GAAG,EAAE;YAClB,MAAM,cAAc,GAAG;YACvB,MAAM,eAAe,GAAG;YACxB,MAAM,mBAAmB,GAAG,CAAC;QACjC;QACA,gBAAgB,CAAC,OAAO;YACpB,MAAM,WAAW,GAAG,OAAO,OAAO;QACtC;IACJ;AACJ;AAEO,MAAM,EACT,UAAU,EACV,iBAAiB,EACjB,kBAAkB,EAClB,gBAAgB,EAChB,qBAAqB,EACrB,wBAAwB,EACxB,wBAAwB,EACxB,gBAAgB,EAChB,cAAc,EACjB,GAAG,YAAY,OAAO;uCAER,YAAY,OAAO","debugId":null}},
    {"offset": {"line": 786, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/store/store.ts"],"sourcesContent":["import { configureStore } from \"@reduxjs/toolkit\";\nimport deviceReducer from './slices/state.slice'\n\n\n\nexport const store = configureStore({\n    reducer: {\n        device: deviceReducer\n    },\n    middleware: (getDefaultMiddleware) =>\n        getDefaultMiddleware({\n            serializableCheck: false\n        })\n})\n\n\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch"],"names":[],"mappings":";;;;AAAA;AACA;;;AAIO,MAAM,QAAQ,IAAA,gNAAc,EAAC;IAChC,SAAS;QACL,QAAQ,+IAAa;IACzB;IACA,YAAY,CAAC,uBACT,qBAAqB;YACjB,mBAAmB;QACvB;AACR","debugId":null}},
    {"offset": {"line": 809, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/store/StoreProvider.tsx"],"sourcesContent":["'use client'\n\nimport { useRef } from 'react'\nimport { Provider } from 'react-redux'\nimport { store } from './store'\n\n\nexport default function StoreProvider({\n  children\n}: {\n  children: React.ReactNode\n}) {\n  return <Provider store={store}>{children}</Provider>\n}\n"],"names":[],"mappings":";;;;;AAGA;AACA;AAJA;;;;AAOe,SAAS,cAAc,EACpC,QAAQ,EAGT;IACC,qBAAO,6LAAC,wKAAQ;QAAC,OAAO,0HAAK;kBAAG;;;;;;AAClC;KANwB","debugId":null}}]
}