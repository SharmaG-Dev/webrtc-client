{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/hooks/useSocket.ts"],"sourcesContent":["'use client'\r\n\r\nimport { useEffect, useRef, useState, useCallback } from 'react'\r\nimport { io, Socket } from 'socket.io-client'\r\n\r\nconst SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'https://werbrtc-server.onrender.com'\r\n\r\nlet socketInstance: Socket | null = null\r\n\r\nexport function useSocket() {\r\n  const [isConnected, setIsConnected] = useState(false)\r\n  const socketRef = useRef<Socket | null>(null)\r\n\r\n  const getSocket = useCallback(() => {\r\n    if (!socketInstance) {\r\n      socketInstance = io(SOCKET_URL, {\r\n        transports: ['websocket'],\r\n        reconnection: true,\r\n        reconnectionAttempts: 5,\r\n        reconnectionDelay: 1000,\r\n        autoConnect: false, \r\n      })\r\n    }\r\n    return socketInstance\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    const socket = getSocket()\r\n    socketRef.current = socket\r\n\r\n    const handleConnect = () => setIsConnected(true)\r\n    const handleDisconnect = () => setIsConnected(false)\r\n\r\n    socket.on('connect', handleConnect)\r\n    socket.on('disconnect', handleDisconnect)\r\n\r\n    return () => {\r\n      socket.off('connect', handleConnect)\r\n      socket.off('disconnect', handleDisconnect)\r\n    }\r\n  }, [getSocket])\r\n\r\n  const connect = useCallback(() => {\r\n    socketRef.current?.connect()\r\n  }, [])\r\n\r\n  const disconnect = useCallback(() => {\r\n    socketRef.current?.disconnect()\r\n  }, [])\r\n\r\n  const emit = useCallback(<T,>(event: string, data?: T) => {\r\n    socketRef.current?.emit(event, data)\r\n  }, [])\r\n\r\n  const on = useCallback((event: string, callback: (...args: any[]) => void) => {\r\n    socketRef.current?.on(event, callback)\r\n    return () => socketRef.current?.off(event, callback)\r\n  }, [])\r\n  const off = useCallback((event: string, callback: (...args: any[]) => void) => {\r\n    socketRef.current?.off(event, callback)\r\n    return () => socketRef.current?.off(event, callback)\r\n  }, [])\r\n\r\n\r\n  return { socket: socketRef.current, isConnected, connect, disconnect, emit, on ,off }\r\n}\r\n"],"names":[],"mappings":";;;;AAKmB;AAHnB;AACA;;AAHA;;;AAKA,MAAM,aAAa,2KAAO,CAAC,GAAG,CAAC,sBAAsB,IAAI;AAEzD,IAAI,iBAAgC;AAE7B,SAAS;;IACd,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAC;IAC/C,MAAM,YAAY,IAAA,uKAAM,EAAgB;IAExC,MAAM,YAAY,IAAA,4KAAW;4CAAC;YAC5B,IAAI,CAAC,gBAAgB;gBACnB,iBAAiB,IAAA,wLAAE,EAAC,YAAY;oBAC9B,YAAY;wBAAC;qBAAY;oBACzB,cAAc;oBACd,sBAAsB;oBACtB,mBAAmB;oBACnB,aAAa;gBACf;YACF;YACA,OAAO;QACT;2CAAG,EAAE;IAEL,IAAA,0KAAS;+BAAC;YACR,MAAM,SAAS;YACf,UAAU,OAAO,GAAG;YAEpB,MAAM;qDAAgB,IAAM,eAAe;;YAC3C,MAAM;wDAAmB,IAAM,eAAe;;YAE9C,OAAO,EAAE,CAAC,WAAW;YACrB,OAAO,EAAE,CAAC,cAAc;YAExB;uCAAO;oBACL,OAAO,GAAG,CAAC,WAAW;oBACtB,OAAO,GAAG,CAAC,cAAc;gBAC3B;;QACF;8BAAG;QAAC;KAAU;IAEd,MAAM,UAAU,IAAA,4KAAW;0CAAC;YAC1B,UAAU,OAAO,EAAE;QACrB;yCAAG,EAAE;IAEL,MAAM,aAAa,IAAA,4KAAW;6CAAC;YAC7B,UAAU,OAAO,EAAE;QACrB;4CAAG,EAAE;IAEL,MAAM,OAAO,IAAA,4KAAW;uCAAC,CAAK,OAAe;YAC3C,UAAU,OAAO,EAAE,KAAK,OAAO;QACjC;sCAAG,EAAE;IAEL,MAAM,KAAK,IAAA,4KAAW;qCAAC,CAAC,OAAe;YACrC,UAAU,OAAO,EAAE,GAAG,OAAO;YAC7B;6CAAO,IAAM,UAAU,OAAO,EAAE,IAAI,OAAO;;QAC7C;oCAAG,EAAE;IACL,MAAM,MAAM,IAAA,4KAAW;sCAAC,CAAC,OAAe;YACtC,UAAU,OAAO,EAAE,IAAI,OAAO;YAC9B;8CAAO,IAAM,UAAU,OAAO,EAAE,IAAI,OAAO;;QAC7C;qCAAG,EAAE;IAGL,OAAO;QAAE,QAAQ,UAAU,OAAO;QAAE;QAAa;QAAS;QAAY;QAAM;QAAI;IAAI;AACtF;GAxDgB","debugId":null}}]
}