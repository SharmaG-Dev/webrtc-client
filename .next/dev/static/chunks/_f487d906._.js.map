{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/hooks/useSocket.ts"],"sourcesContent":["'use client'\r\n\r\nimport { useEffect, useRef, useState, useCallback } from 'react'\r\nimport { io, Socket } from 'socket.io-client'\r\n\r\nconst SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'https://werbrtc-server.onrender.com'\r\n\r\nlet socketInstance: Socket | null = null\r\n\r\nexport function useSocket() {\r\n  const [isConnected, setIsConnected] = useState(false)\r\n  const socketRef = useRef<Socket | null>(null)\r\n\r\n  const getSocket = useCallback(() => {\r\n    if (!socketInstance) {\r\n      socketInstance = io(SOCKET_URL, {\r\n        transports: ['websocket'],\r\n        reconnection: true,\r\n        reconnectionAttempts: 5,\r\n        reconnectionDelay: 1000,\r\n        autoConnect: false, \r\n      })\r\n    }\r\n    return socketInstance\r\n  }, [])\r\n\r\n  useEffect(() => {\r\n    const socket = getSocket()\r\n    socketRef.current = socket\r\n\r\n    const handleConnect = () => setIsConnected(true)\r\n    const handleDisconnect = () => setIsConnected(false)\r\n\r\n    socket.on('connect', handleConnect)\r\n    socket.on('disconnect', handleDisconnect)\r\n\r\n    return () => {\r\n      socket.off('connect', handleConnect)\r\n      socket.off('disconnect', handleDisconnect)\r\n    }\r\n  }, [getSocket])\r\n\r\n  const connect = useCallback(() => {\r\n    socketRef.current?.connect()\r\n  }, [])\r\n\r\n  const disconnect = useCallback(() => {\r\n    socketRef.current?.disconnect()\r\n  }, [])\r\n\r\n  const emit = useCallback(<T,>(event: string, data?: T) => {\r\n    socketRef.current?.emit(event, data)\r\n  }, [])\r\n\r\n  const on = useCallback((event: string, callback: (...args: any[]) => void) => {\r\n    socketRef.current?.on(event, callback)\r\n    return () => socketRef.current?.off(event, callback)\r\n  }, [])\r\n  const off = useCallback((event: string, callback: (...args: any[]) => void) => {\r\n    socketRef.current?.off(event, callback)\r\n    return () => socketRef.current?.off(event, callback)\r\n  }, [])\r\n\r\n\r\n  return { socket: socketRef.current, isConnected, connect, disconnect, emit, on ,off }\r\n}\r\n"],"names":[],"mappings":";;;;AAKmB;AAHnB;AACA;;AAHA;;;AAKA,MAAM,aAAa,2KAAO,CAAC,GAAG,CAAC,sBAAsB,IAAI;AAEzD,IAAI,iBAAgC;AAE7B,SAAS;;IACd,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAC;IAC/C,MAAM,YAAY,IAAA,uKAAM,EAAgB;IAExC,MAAM,YAAY,IAAA,4KAAW;4CAAC;YAC5B,IAAI,CAAC,gBAAgB;gBACnB,iBAAiB,IAAA,wLAAE,EAAC,YAAY;oBAC9B,YAAY;wBAAC;qBAAY;oBACzB,cAAc;oBACd,sBAAsB;oBACtB,mBAAmB;oBACnB,aAAa;gBACf;YACF;YACA,OAAO;QACT;2CAAG,EAAE;IAEL,IAAA,0KAAS;+BAAC;YACR,MAAM,SAAS;YACf,UAAU,OAAO,GAAG;YAEpB,MAAM;qDAAgB,IAAM,eAAe;;YAC3C,MAAM;wDAAmB,IAAM,eAAe;;YAE9C,OAAO,EAAE,CAAC,WAAW;YACrB,OAAO,EAAE,CAAC,cAAc;YAExB;uCAAO;oBACL,OAAO,GAAG,CAAC,WAAW;oBACtB,OAAO,GAAG,CAAC,cAAc;gBAC3B;;QACF;8BAAG;QAAC;KAAU;IAEd,MAAM,UAAU,IAAA,4KAAW;0CAAC;YAC1B,UAAU,OAAO,EAAE;QACrB;yCAAG,EAAE;IAEL,MAAM,aAAa,IAAA,4KAAW;6CAAC;YAC7B,UAAU,OAAO,EAAE;QACrB;4CAAG,EAAE;IAEL,MAAM,OAAO,IAAA,4KAAW;uCAAC,CAAK,OAAe;YAC3C,UAAU,OAAO,EAAE,KAAK,OAAO;QACjC;sCAAG,EAAE;IAEL,MAAM,KAAK,IAAA,4KAAW;qCAAC,CAAC,OAAe;YACrC,UAAU,OAAO,EAAE,GAAG,OAAO;YAC7B;6CAAO,IAAM,UAAU,OAAO,EAAE,IAAI,OAAO;;QAC7C;oCAAG,EAAE;IACL,MAAM,MAAM,IAAA,4KAAW;sCAAC,CAAC,OAAe;YACtC,UAAU,OAAO,EAAE,IAAI,OAAO;YAC9B;8CAAO,IAAM,UAAU,OAAO,EAAE,IAAI,OAAO;;QAC7C;qCAAG,EAAE;IAGL,OAAO;QAAE,QAAQ,UAAU,OAAO;QAAE;QAAa;QAAS;QAAY;QAAM;QAAI;IAAI;AACtF;GAxDgB","debugId":null}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///home/user/webrtc-client/provider/useWebRTC.tsx"],"sourcesContent":["\"use client\"\nimport { useSocket } from \"@/hooks/useSocket\";\nimport { createContext, ReactNode, useCallback, useContext, useEffect, useState } from \"react\";\n\ninterface MessageI {\n    messageType: 'success' | 'error',\n    message: string\n}\n\ninterface WebRtcInterface {\n    peerConnections: Map<string, RTCPeerConnection>;\n    connectDevice: (deviceIp: string) => void;\n    createOffer: (deviceIp: string) => Promise<RTCSessionDescriptionInit | void>;\n    createAnswer: (deviceIp: string) => Promise<RTCSessionDescriptionInit | void>;\n    pushMessage: (msg: MessageI) => void;\n    removeMessage: (msg: MessageI) => void;\n    message: MessageI[];\n    connectedDevices: Set<string>;\n    disconnectDevice: (deviceIp: string) => void;\n}\n\nexport const WebRTCContext = createContext<WebRtcInterface | null>(null);\n\nexport const useWebRTC = () => {\n    const context = useContext(WebRTCContext);\n\n    if (!context) {\n        throw new Error('useWebRTC must be used within a WebRtcProvider');\n    }\n\n    return context;\n};\n\nexport const WebRtcProvider = ({ children }: { children: ReactNode }) => {\n    const { emit, isConnected, on, off } = useSocket();\n    const [message, setMessage] = useState<MessageI[]>([]);\n    const [peerConnections, setPeerConnections] = useState<Map<string, RTCPeerConnection>>(new Map());\n    const [connectedDevices, setConnectedDevices] = useState<Set<string>>(new Set());\n\n    const pushMessage = useCallback(({ message, messageType }: MessageI) => {\n        setMessage(prev => [...prev, { message, messageType }]);\n\n        // Auto-remove success messages after 5 seconds\n        if (messageType === 'success') {\n            setTimeout(() => {\n                removeMessage({ message, messageType });\n            }, 5000);\n        }\n    }, []);\n\n    const removeMessage = useCallback(({ message, messageType }: MessageI) => {\n        setMessage(prev => prev.filter(\n            item => !(item.message === message && item.messageType === messageType)\n        ));\n    }, []);\n\n    const connectDevice = useCallback(async (deviceIp: string) => {\n        if (!isConnected) {\n            pushMessage({ message: 'Socket is not connected', messageType: 'error' });\n            return;\n        }\n        if (!deviceIp) {\n            pushMessage({ message: 'Invalid device IP', messageType: 'error' });\n            return;\n        }\n        if (peerConnections.has(deviceIp)) {\n            console.log('Peer connection already exists for', deviceIp);\n            return;\n        }\n\n        console.log('ðŸ”Œ Creating peer connection for:', deviceIp);\n\n        const peerConnection = new RTCPeerConnection({\n            iceServers: [\n                { urls: 'stun:stun.l.google.com:19302' },\n                { urls: 'stun:stun1.l.google.com:19302' }\n            ],\n            iceCandidatePoolSize: 10\n        });\n\n        // Connection state change listener\n        peerConnection.addEventListener('connectionstatechange', () => {\n            console.log(`ðŸ“¡ Connection state for ${deviceIp}: ${peerConnection.connectionState}`);\n\n            switch (peerConnection.connectionState) {\n                case 'connected':\n                    console.log('âœ… WebRTC connection established with:', deviceIp);\n                    emit('webrtc-connected', { targetIp: deviceIp });\n                    setConnectedDevices(prev => new Set(prev).add(deviceIp));\n                    pushMessage({\n                        message: `Connected to ${deviceIp}`,\n                        messageType: 'success'\n                    });\n                    break;\n                case 'disconnected':\n                    console.log('âš ï¸ WebRTC connection disconnected:', deviceIp);\n                    pushMessage({\n                        message: `Disconnected from ${deviceIp}`,\n                        messageType: 'error'\n                    });\n                    break;\n                case 'failed':\n                    console.log('âŒ WebRTC connection failed:', deviceIp);\n                    setConnectedDevices(prev => {\n                        const newSet = new Set(prev);\n                        newSet.delete(deviceIp);\n                        return newSet;\n                    });\n                    emit('webrtc-disconnected', { targetIp: deviceIp });\n                    pushMessage({\n                        message: `Connection failed with ${deviceIp}`,\n                        messageType: 'error'\n                    });\n                    break;\n                case 'closed':\n                    console.log('ðŸ”’ WebRTC connection closed:', deviceIp);\n                    setConnectedDevices(prev => {\n                        const newSet = new Set(prev);\n                        newSet.delete(deviceIp);\n                        return newSet;\n                    });\n                    emit('webrtc-disconnected', { targetIp: deviceIp });\n                    break;\n            }\n        });\n\n        // ICE connection state change listener\n        peerConnection.addEventListener('iceconnectionstatechange', () => {\n            console.log(`ðŸ§Š ICE connection state for ${deviceIp}: ${peerConnection.iceConnectionState}`);\n        });\n\n        // ICE candidate handler\n        peerConnection.onicecandidate = (event: RTCPeerConnectionIceEvent) => {\n            if (event.candidate) {\n                console.log('ðŸ§Š Sending ICE candidate to:', deviceIp);\n                emit('ice-candidate', {\n                    targetIp: deviceIp,\n                    candidate: event.candidate\n                });\n            }\n        };\n\n        const newPeerConnections = new Map(peerConnections);\n        newPeerConnections.set(deviceIp, peerConnection);\n        setPeerConnections(newPeerConnections);\n\n    }, [isConnected, emit, peerConnections, pushMessage]);\n\n    const createOffer = useCallback(async (deviceIp: string) => {\n        if (!isConnected) {\n            pushMessage({ message: 'Socket is not connected', messageType: 'error' });\n            return;\n        }\n        if (!deviceIp) {\n            pushMessage({ message: 'Invalid device IP', messageType: 'error' });\n            return;\n        }\n\n        const peerConnection = peerConnections.get(deviceIp);\n        if (!peerConnection) {\n            pushMessage({ message: 'Peer connection not found', messageType: 'error' });\n            return;\n        }\n\n        console.log('ðŸ“¤ Creating offer for:', deviceIp);\n        const offer = await peerConnection.createOffer();\n        await peerConnection.setLocalDescription(offer);\n\n        emit('offer', {\n            targetIp: deviceIp,\n            sdp: offer\n        });\n\n        return offer;\n    }, [isConnected, peerConnections, emit, pushMessage]);\n\n    const createAnswer = useCallback(async (deviceIp: string) => {\n        if (!isConnected) {\n            pushMessage({ message: 'Socket is not connected', messageType: 'error' });\n            return;\n        }\n        if (!deviceIp) {\n            pushMessage({ message: 'Invalid device IP', messageType: 'error' });\n            return;\n        }\n\n        const peerConnection = peerConnections.get(deviceIp);\n        if (!peerConnection) {\n            pushMessage({ message: 'Peer connection not found', messageType: 'error' });\n            return;\n        }\n\n        console.log('ðŸ“¥ Creating answer for:', deviceIp);\n        const answer = await peerConnection.createAnswer();\n        await peerConnection.setLocalDescription(answer);\n\n        emit('answer', {\n            targetIp: deviceIp,\n            sdp: answer\n        });\n\n        return answer;\n    }, [isConnected, peerConnections, emit, pushMessage]);\n\n    const disconnectDevice = useCallback((deviceIp: string) => {\n        const peerConnection = peerConnections.get(deviceIp);\n\n        if (peerConnection) {\n            console.log('ðŸ”Œ Closing peer connection for:', deviceIp);\n            peerConnection.close();\n\n            const newPeerConnections = new Map(peerConnections);\n            newPeerConnections.delete(deviceIp);\n            setPeerConnections(newPeerConnections);\n\n            setConnectedDevices(prev => {\n                const newSet = new Set(prev);\n                newSet.delete(deviceIp);\n                return newSet;\n            });\n\n            emit('webrtc-disconnected', { targetIp: deviceIp });\n        }\n    }, [peerConnections, emit]);\n\n    useEffect(() => {\n        if (!isConnected) {\n            return;\n        }\n\n        // Handle incoming offer\n        const handleOffer = async (data: { from: string; sdp: RTCSessionDescriptionInit }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ“¥ Received offer from:', fromDeviceIp);\n\n            // Create peer connection if it doesn't exist\n            if (!peerConnections.has(fromDeviceIp)) {\n                await connectDevice(fromDeviceIp);\n            }\n\n            const peerConnection = peerConnections.get(fromDeviceIp);\n            if (!peerConnection) {\n                pushMessage({ message: 'Peer connection not found', messageType: 'error' });\n                return;\n            }\n\n            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));\n            await createAnswer(fromDeviceIp);\n        };\n\n        // Handle incoming answer\n        const handleAnswer = async (data: { from: string; sdp: RTCSessionDescriptionInit }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ“¥ Received answer from:', fromDeviceIp);\n\n            const peerConnection = peerConnections.get(fromDeviceIp);\n            if (!peerConnection) {\n                pushMessage({ message: 'Peer connection not found', messageType: 'error' });\n                return;\n            }\n\n            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));\n        };\n\n        // Handle incoming ICE candidate\n        const handleIceCandidate = async (data: { from: string; candidate: RTCIceCandidate }) => {\n            const fromDeviceIp = data.from;\n            console.log('ðŸ§Š Received ICE candidate from:', fromDeviceIp);\n\n            const peerConnection = peerConnections.get(fromDeviceIp);\n            if (!peerConnection) {\n                pushMessage({ message: 'Peer connection not found for ICE candidate', messageType: 'error' });\n                return;\n            }\n\n            try {\n                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));\n            } catch (err) {\n                console.error(\"âŒ Error adding ICE candidate:\", err);\n            }\n        };\n\n        // Handle connection notification from other device\n        const handleWebRTCConnected = (data: { fromIp: string }) => {\n            console.log('âœ… Received connection notification from:', data.fromIp);\n            setConnectedDevices(prev => new Set(prev).add(data.fromIp));\n            pushMessage({\n                message: `Connected to ${data.fromIp}`,\n                messageType: 'success'\n            });\n        };\n\n        // Handle disconnection notification\n        const handleWebRTCDisconnected = (data: { fromIp: string }) => {\n            console.log('âŒ Received disconnection notification from:', data.fromIp);\n            setConnectedDevices(prev => {\n                const newSet = new Set(prev);\n                newSet.delete(data.fromIp);\n                return newSet;\n            });\n        };\n\n        on('offer', handleOffer);\n        on('answer', handleAnswer);\n        on('ice-candidate', handleIceCandidate);\n        on('webrtc-connection-notify', handleWebRTCConnected);\n        on('webrtc-disconnection-notify', handleWebRTCDisconnected);\n\n        return () => {\n            off('offer', handleOffer);\n            off('answer', handleAnswer);\n            off('ice-candidate', handleIceCandidate);\n            off('webrtc-connection-notify', handleWebRTCConnected);\n            off('webrtc-disconnection-notify', handleWebRTCDisconnected);\n        };\n    }, [isConnected, on, off, peerConnections, connectDevice, createAnswer, pushMessage]);\n\n    return (\n        <WebRTCContext.Provider value={{\n            peerConnections,\n            connectDevice,\n            createAnswer,\n            createOffer,\n            removeMessage,\n            pushMessage,\n            message,\n            connectedDevices,\n            disconnectDevice\n        }}>\n            {children}\n        </WebRTCContext.Provider>\n    );\n};\n"],"names":[],"mappings":"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","debugId":null}}]
}